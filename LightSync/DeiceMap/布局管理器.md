好！下面是一套**多设备布局器**的完整伪代码框架：

* 支持在画布上**拖拽设备**定位与旋转
* **每个设备单独效果** / **统一一个效果**
* 统一效果支持**左→右 / 中心→外 / 外→内**排序与相位控制
* 可扩展到屏幕同屏、音频、渐变、跑马、呼吸等效果

---

# 1) 数据模型

```cpp
// 画布坐标系：左上(0,0)，单位px
struct Vec2 { float x, y; };
struct Rect { float x,y,w,h; };

enum OrderMode { LeftToRight, CenterToOutside, OutsideToCenter };
enum Orientation { Forward, Reverse };   // LED顺序方向
enum EffectType { Solid, Gradient, Rainbow, Breathe, Comet, Ambilight, AudioReactive };

struct EffectPreset {
    EffectType type;
    float speed;             // 通用速度
    float hueShift;          // 色调偏移(统一效果常用)
    float saturation;        // 0..2
    float brightness;        // 0..1
    // Ambilight专用
    int monitorId;
    Rect captureZone;        // 归一化或像素均可
    float edgeDistance;
    // 其他效果的参数...
};

struct DeviceNode {
    string id;               // 设备唯一ID
    string name;
    int    leds;             // LED数量
    vector<Vec2> ledMap;     // 可选：归一化0..1坐标；为空用均匀分布
    Rect   bounds;           // 在布局器上的矩形(位置+尺寸)
    float  rotationDeg;      // 0/90/180/270 or 任意
    Orientation orientation; // 正向或反向
    // 设备效果覆盖(可选)
    bool           hasLocalEffect = false;
    EffectPreset   localEffect;
    // 运行期缓存
    vector<uint32_t> frame;  // 本帧颜色缓冲(ARGB)
};

struct LayoutState {
    vector<DeviceNode> devices;
    // 统一效果(当没有localEffect或选择“统一控制”时生效)
    bool useUnifiedEffect = true;
    EffectPreset unifiedEffect;
    OrderMode    orderMode = LeftToRight;
    // 排序计算缓存
    vector<int>  orderedDeviceIdx; // 排序后的设备索引
    // 画布参数
    Rect canvas; // 画布大小
};
```

---

# 2) 画布与交互（拖拽、选择、设置效果）

```cpp
// 鼠标交互
onMouseDown(pos):
    hit = pickDeviceAt(pos)
    if hit:
        drag.active = true
        drag.deviceIndex = hit.index
        drag.offset = pos - device.bounds.topLeft

onMouseMove(pos):
    if drag.active:
        device = state.devices[drag.deviceIndex]
        device.bounds.x = pos.x - drag.offset.x
        device.bounds.y = pos.y - drag.offset.y
        requestRepaint()

onMouseUp(pos):
    drag.active = false
    // 可选：吸附到网格/边缘
    snapToGrid(state.devices[drag.deviceIndex])

// 右键菜单：设置“本设备效果”或“使用统一效果”
onContextMenu(deviceIndex):
    showMenu([
      "设置本设备效果", () => openEffectDialog(deviceIndex),
      "使用统一效果", () => state.devices[deviceIndex].hasLocalEffect=false
    ])
```

---

# 3) 排序策略（统一效果用）

```cpp
computeOrdering():
    center = { state.canvas.x + state.canvas.w/2, state.canvas.y + state.canvas.h/2 }
    vec<pair<int,float>> key; // (deviceIndex, keyValue)

    switch (state.orderMode):
      case LeftToRight:
          for i,dev in enumerate(state.devices):
              cx = dev.bounds.x + dev.bounds.w/2
              key.push_back({i, cx})
          sort key by keyValue ascending
          break

      case CenterToOutside:
          for i,dev:
              cx = dev.bounds.x + dev.bounds.w/2
              cy = dev.bounds.y + dev.bounds.h/2
              d = distance( {cx,cy}, center )
              key.push_back({i, d})
          sort key by keyValue ascending     // 近→远
          break

      case OutsideToCenter:
          for i,dev:
              cx = dev.bounds.x + dev.bounds.w/2
              cy = dev.bounds.y + dev.bounds.h/2
              d = distance( {cx,cy}, center )
              key.push_back({i, d})
          sort key by keyValue descending    // 远→近
          break

    state.orderedDeviceIdx = [p.first for p in key]
```

> 可选：**交错排序**（中心向两侧交替）
> 对 `CenterToOutside` 结果做 `interleave(left,right)` 以产生从中心向两侧扩散的“拨浪鼓”效果。

---

# 4) 播放循环（统一效果 + 独立效果）

```cpp
tick(dt, t): // dt:秒, t:全局时间
    if (state.useUnifiedEffect) computeOrdering()

    for idx in 0..state.devices.size-1:
        dev = state.devices[idx]
        if (dev.hasLocalEffect):
            colors = renderEffect(dev.localEffect, dev, dt, t, /*orderPhase=*/0, /*rank=*/0, /*rankCount=*/1)
        else if (state.useUnifiedEffect):
            rank = indexOf(state.orderedDeviceIdx, idx)           // 当前设备在排序中的名次
            rankCount = state.devices.size()
            orderPhase = float(rank) / max(1, rankCount-1)        // 0..1
            colors = renderEffect(state.unifiedEffect, dev, dt, t, orderPhase, rank, rankCount)
        else {
            // 没有本地也不使用统一 → 忽略或保留上帧
            continue
        }

        // 方向与旋转
        if (dev.orientation == Reverse) reverse(colors)
        colors = rotateByDevice(colors, dev.rotationDeg) // 如需将效果角度与摆放对齐

        dev.frame = colors
        sendToHardware(dev.id, colors)
```

---

# 5) 渲染统一效果（核心：相位与全局进度）

```cpp
vector<Color> renderEffect(EffectPreset e, DeviceNode dev, float dt, float t,
                           float orderPhase, int rank, int rankCount)
{
    switch (e.type):

      case Solid:
          return fill(dev.leds, hsv2rgb({e.hueShift, e.saturation, e.brightness}))

      case Gradient:
          // 统一效果：整排设备视为一条“总带”，orderPhase决定本设备在总带的位置
          // 计算本设备起止全局区间，用于取渐变
          start = orderPhase
          span  = 1.0f / rankCount
          return sampleGradientOverSpan(dev.leds, start, span, e, t)

      case Rainbow:
          // 相位 = 设备排序名次，形成左→右/中心→外的相位差
          base = t * e.speed + orderPhase
          return perLed(dev.leds, i -> hsv2rgb({ base + i/dev.leds, e.saturation, e.brightness }))

      case Breathe:
          amp = 0.5f + 0.5f * sin(TAU*(t*e.speed + orderPhase))
          return fill(dev.leds, hsv2rgb({ e.hueShift, e.saturation, amp*e.brightness }))

      case Comet:
          // 一个“彗星”沿全局顺序移动；orderPhase决定该设备上的彗星位置
          head = fract(t * e.speed)            // 0..1
          // 把全局 head 投影到本设备区间
          start = orderPhase
          span  = 1.0f / rankCount
          headLocal = (head - start) / span    // 本设备局部0..1
          return drawComet(dev.leds, headLocal, e)

      case Ambilight:
          // e.captureZone: 每个设备可不同（若本地效果），或统一效果时统一区域
          bitmap = captureScreen(e.monitorId, e.captureZone, e.edgeDistance)
          return mapAmbilight(bitmap, dev)     // 利用dev.ledMap或四边均匀

      case AudioReactive:
          energy = getBandEnergy(/*params*/)   // 外部音频输入
          phase  = t * e.speed + orderPhase
          return audioColors(dev.leds, energy, phase, e)

    return fill(dev.leds, {0,0,0})
}
```

---

# 6) 统一效果的三种“统一控制”策略

**左→右**

* `computeOrdering()` 按中心 X 排序
* `orderPhase = rank/(count-1)`
* 适用：Rainbow、跑马、彗星、渐变

**中心→外**

* 按距离中心升序排序
* `orderPhase` 同上
* 可交错输出让左右两侧对称扩散：`interleave(nearLeft, nearRight, ...)`

**外→内**

* 按距离中心降序排序
* 适用：外缘点亮往中间汇聚的彗星/波纹

> 注：**orderPhase** 进入渲染器后，通常被用作**相位偏移**或**局部区间映射**，从而让一个效果能“贯穿所有设备”。

---

# 7) Ambilight 与区域绑定（可选）

```cpp
// 统一Ambilight：所有设备共享同一个区域
state.unifiedEffect = {
    type: Ambilight,
    monitorId: 0,
    captureZone: {x:0,y:0,w:screen.w,h:screen.h}, // 或UI提供的矩形
    edgeDistance: 0.06
}

// 设备独立 Ambilight：右键设备 → 设置本设备效果 → 为每个设备绑定不同 captureZone
device.localEffect = {
    type: Ambilight,
    monitorId: 1,
    captureZone: {x: 0, y: 0, w: screen.w/2
```
文件名可对应:layout_device.h/.cpp、layout_item.*、light_effect.*、effect_binding.*、layout_scene.*、layout_canvas.*、drag_controller.*