> 文件: docs/布局管理器.md  
> 描述: 多设备布局器设计与实现说明（数据模型、交互、排序、渲染、Ambilight）  
> 作者: zhou  
> 日期: 2025-09-04

---

## 简介

多设备布局器用于在统一画布上组织多个 RGB 设备的空间位置与播放顺序，并在“统一效果”或“设备本地效果”两种策略间切换，以实现贯穿所有设备的连续动态效果（同屏、音乐、渐变、彩虹、呼吸、彗星等）。

### 目标

- 清晰的数据模型，便于序列化与回放。
- 直观的画布交互：拖拽、旋转、吸附、对齐、撤销重做。
- 统一效果的排序与相位控制：左→右、中心→外、外→内，支持交错。
- 可扩展渲染器接口，支持 Ambilight、音频响应等扩展。

### 适用范围

- UI 层：页面、画布与交互（Qt Widgets）。
- 服务层：LayoutService、EffectService 与 Screen/Audio 捕获服务的协作。
- 设备通道：通过 DeviceService/OpenRGB 下发颜色帧。

---

## 模块与职责

- 画布与交互（LayoutCanvas / LayoutScene）：拾取、拖拽、旋转、吸附、框选、对齐分布、撤销重做。
- 数据模型（LayoutState）：设备节点、排序缓存、统一效果。
- 排序策略（Ordering）：依据 X 中心、距全局中心等生成设备顺序。
- 渲染器（Effect Renderers）：输入统一/本地效果与相位，产出每设备颜色帧。
- 下发（DeviceService）：将每设备 `frame` 批量写入硬件。

---

## 数据模型

```cpp
// 画布坐标系：左上(0,0)，单位px
struct Vec2 { float x, y; };
struct Rect { float x,y,w,h; };

enum OrderMode { LeftToRight, CenterToOutside, OutsideToCenter };
enum Orientation { Forward, Reverse };   // LED顺序方向
enum EffectType { Solid, Gradient, Rainbow, Breathe, Comet, Ambilight, AudioReactive };

struct EffectPreset {
    EffectType type;
    float speed;             // 通用速度
    float hueShift;          // 色调偏移(统一效果常用)
    float saturation;        // 0..2
    float brightness;        // 0..1
    // Ambilight专用
    int   monitorId;
    Rect  captureZone;       // 归一化或像素均可
    float edgeDistance;
    // 其他效果参数可扩展...
};

struct DeviceNode {
    string id;               // 设备唯一ID
    string name;
    int    leds;             // LED数量
    vector<Vec2> ledMap;     // 可选：归一化0..1坐标；为空用均匀分布
    Rect   bounds;           // 在布局器上的矩形(位置+尺寸)
    float  rotationDeg;      // 0/90/180/270 或任意角
    Orientation orientation; // 正向或反向
    // 设备本地效果（可选）
    bool           hasLocalEffect = false;
    EffectPreset   localEffect;
    // 运行期缓存
    vector<uint32_t> frame;  // 本帧颜色缓冲(ARGB)
};

struct LayoutState {
    vector<DeviceNode> devices;
    // 统一效果（当没有 localEffect 或选择“统一控制”时生效）
    bool useUnifiedEffect = true;
    EffectPreset unifiedEffect;
    OrderMode    orderMode = LeftToRight;
    // 排序计算缓存
    vector<int>  orderedDeviceIdx; // 排序后的设备索引
    // 画布参数
    Rect canvas; // 画布大小
};
```

约定：UI/文档使用中文；渲染器与日志内部注释建议使用英语；日志统一通过 `LogManager`。

---

## 画布与交互（拖拽、选择、设置效果）

```cpp
// 鼠标交互
onMouseDown(pos):
    hit = pickDeviceAt(pos)
    if hit:
        drag.active = true
        drag.deviceIndex = hit.index
        drag.offset = pos - device.bounds.topLeft

onMouseMove(pos):
    if drag.active:
        device = state.devices[drag.deviceIndex]
        device.bounds.x = pos.x - drag.offset.x
        device.bounds.y = pos.y - drag.offset.y
        requestRepaint()

onMouseUp(pos):
    drag.active = false
    // 可选：吸附到网格/边缘
    snapToGrid(state.devices[drag.deviceIndex])

// 右键菜单：设置“本设备效果”或“使用统一效果”
onContextMenu(deviceIndex):
    showMenu([
      "设置本设备效果", () => openEffectDialog(deviceIndex),
      "使用统一效果", () => state.devices[deviceIndex].hasLocalEffect=false
    ])
```

实现要点：

- 吸附与对齐线在 UI 层完成，变更后仅写入 `DeviceNode.bounds`。
- 旋转以设备中心为基准；必要时在渲染阶段做角度对齐。
- 快捷键：复制、粘贴、对齐、等距分布、撤销/重做。

---

## 排序策略（统一效果用）

```cpp
computeOrdering():
    center = { state.canvas.x + state.canvas.w/2, state.canvas.y + state.canvas.h/2 }
    vec<pair<int,float>> key; // (deviceIndex, keyValue)

    switch (state.orderMode):
      case LeftToRight:
          for i,dev in enumerate(state.devices):
              cx = dev.bounds.x + dev.bounds.w/2
              key.push_back({i, cx})
          sort key by keyValue ascending
          break

      case CenterToOutside:
          for i,dev:
              cx = dev.bounds.x + dev.bounds.w/2
              cy = dev.bounds.y + dev.bounds.h/2
              d = distance( {cx,cy}, center )
              key.push_back({i, d})
          sort key by keyValue ascending     // 近→远
          break

      case OutsideToCenter:
          for i,dev:
              cx = dev.bounds.x + dev.bounds.w/2
              cy = dev.bounds.y + dev.bounds.h/2
              d = distance( {cx,cy}, center )
              key.push_back({i, d})
          sort key by keyValue descending    // 远→近
          break

    state.orderedDeviceIdx = [p.first for p in key]
```

提示：对 `CenterToOutside` 结果做交错（interleave 左/右）可得到对称扩散效果。

---

## 播放循环（统一效果 + 独立效果）

```cpp
tick(dt, t): // dt:秒, t:全局时间
    if (state.useUnifiedEffect) computeOrdering()

    for idx in 0..state.devices.size-1:
        dev = state.devices[idx]
        if (dev.hasLocalEffect):
            colors = renderEffect(dev.localEffect, dev, dt, t, /*orderPhase=*/0, /*rank=*/0, /*rankCount=*/1)
        else if (state.useUnifiedEffect):
            rank = indexOf(state.orderedDeviceIdx, idx)           // 当前设备在排序中的名次
            rankCount = state.devices.size()
            orderPhase = float(rank) / max(1, rankCount-1)        // 0..1
            colors = renderEffect(state.unifiedEffect, dev, dt, t, orderPhase, rank, rankCount)
        else:
            continue

        // 方向与旋转
        if (dev.orientation == Reverse) reverse(colors)
        colors = rotateByDevice(colors, dev.rotationDeg) // 若需将效果角度与摆放对齐

        dev.frame = colors
        sendToHardware(dev.id, colors)
```

---

## 渲染统一效果（相位与全局进度）

```cpp
vector<Color> renderEffect(EffectPreset e, DeviceNode dev, float dt, float t,
                           float orderPhase, int rank, int rankCount)
{
    switch (e.type):

      case Solid:
          return fill(dev.leds, hsv2rgb({e.hueShift, e.saturation, e.brightness}))

      case Gradient:
          // 整排设备视为一条“总带”，orderPhase 决定本设备在总带的位置
          start = orderPhase
          span  = 1.0f / rankCount
          return sampleGradientOverSpan(dev.leds, start, span, e, t)

      case Rainbow:
          // 相位 = 设备排序名次
          base = t * e.speed + orderPhase
          return perLed(dev.leds, i -> hsv2rgb({ base + i/dev.leds, e.saturation, e.brightness }))

      case Breathe:
          amp = 0.5f + 0.5f * sin(TAU*(t*e.speed + orderPhase))
          return fill(dev.leds, hsv2rgb({ e.hueShift, e.saturation, amp*e.brightness }))

      case Comet:
          head = fract(t * e.speed)            // 0..1 全局头部
          start = orderPhase
          span  = 1.0f / rankCount
          headLocal = (head - start) / span    // 本设备局部0..1
          return drawComet(dev.leds, headLocal, e)

      case Ambilight:
          bitmap = captureScreen(e.monitorId, e.captureZone, e.edgeDistance)
          return mapAmbilight(bitmap, dev)     // 利用 dev.ledMap 或四边均匀

      case AudioReactive:
          energy = getBandEnergy(/*params*/)
          phase  = t * e.speed + orderPhase
          return audioColors(dev.leds, energy, phase, e)

    return fill(dev.leds, {0,0,0})
}
```

---

## 统一控制的排序策略摘要

- 左→右：按中心 X 升序；`orderPhase = rank/(count-1)`。
- 中心→外：按距中心升序；可交错以获得左右对称扩散。
- 外→内：按距中心降序；适合“向中聚拢”的脉冲/波纹/彗星。

---

## Ambilight 与区域绑定

```cpp
// 统一 Ambilight：所有设备共享一个区域
state.unifiedEffect = {
    type: Ambilight,
    monitorId: 0,
    captureZone: {x:0,y:0,w:screen.w,h:screen.h},
    edgeDistance: 0.06
}

// 设备独立 Ambilight：为每个设备绑定不同 captureZone
device.localEffect = {
    type: Ambilight,
    monitorId: 1,
    captureZone: {x: 0, y: 0, w: screen.w/2 /* ... */}
}
```

---

## 与 OpenRGB / 核心服务协作

- `ScreenCaptureService`/`AudioCaptureService` 生成源数据（帧/频谱）。
- `EffectService` 驱动渲染器按目标 FPS 产出每设备颜色帧。
- `DeviceService` 负责批量下发颜色帧至设备（OpenRGB 控制器）。
- UI 仅通过服务 API 写入；订阅信号刷新视图（高内聚、低耦合）。

---

## 文件命名与模块落地（建议）

- `ui/pages/LayoutDesignerPage/`：页面、工具栏、属性面板。
- `ui/pages/LayoutDesignerPage/layout_canvas.*`：画布与交互（或沿用现有 `layout_scene.*`）。
- `ui/pages/LayoutDesignerPage/drag_controller.*`：拖拽/吸附/对齐。
- `core/services/LayoutService.*`：排序、序列化、会话管理。
- `core/effects/`：`light_effect.*` 与渲染器实现在此分层。
- 历史目录如 `DeiceMap/` 建议逐步并入上述结构，避免语义分散。

---

## 性能与调试要点

- 分块并行与缓存：对昂贵计算（映射/采样）做缓存与分块处理。
- 降级策略：在高负载下降帧或降采样，保证流畅度优先。
- 日志：效果切换、排序重算、帧生成/下发耗时埋点，统一 `LogManager`。
- 可视化：帧率/延迟叠加、采样热力图、设备相位预览。

---

## 术语

- 统一效果（Unified Effect）：所有设备受同一效果驱动，按排序/相位贯穿。
- 本地效果（Local Effect）：单个设备独立效果，优先级高于统一效果。
- 相位（Phase）：用于在统一时间轴上错位设备的 0..1 浮点参数。

---

## 变更记录

- 2025-09-04: 初版编写，补充模块职责、协作关系与性能要点；从 `LightSync/DeiceMap/布局管理器.md` 迁移到 `docs/`。


